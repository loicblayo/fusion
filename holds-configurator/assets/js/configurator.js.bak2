document.addEventListener('DOMContentLoaded', () => {
  const canvas = document.getElementById('holds-canvas');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(canvas.clientWidth, 400, false);

  // Scene & camera
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf0f0f0);
  const camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / 400, 0.1, 1000);
  camera.position.set(0, 0, 10);

  scene.add(new THREE.AmbientLight(0x404040));
  const dirLight = new THREE.DirectionalLight(0xffffff, 1);
  dirLight.position.set(2, 2, 5);
  scene.add(dirLight);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  let mesh, geometry, vertexHelpers = [], modeLibre = false;
  let currentShape = "cube";
  let params = { width: 5, height: 5, depth: 5, radius: 2.5, length: 5, flatten: 1, rugosite: 0 };
  let noise = new SimplexNoise();

  // UI
  const shapeSelect = document.getElementById('shape');
  const paramControls = document.getElementById('param-controls');
  const rugositeSlider = document.getElementById('rugosite');
  const rugositeValue = document.getElementById('rugosite-value');
  const modeLibreBtn = document.getElementById('mode-libre-btn');
  const modeLibreLabel = document.getElementById('mode-libre-label');
  rugositeValue.innerText = rugositeSlider.value;

  // --- UI dynamique
  function updateParamControls() {
    paramControls.innerHTML = '';
    if (currentShape === "cube" || currentShape === "pyramid") {
      paramControls.innerHTML += `
        <label>Largeur :<input type="number" id="width" min="1" max="20" step="0.1" value="${params.width}" style="width:50px;margin-left:2px;margin-right:12px;"></label>
        <label>Hauteur :<input type="number" id="height" min="1" max="20" step="0.1" value="${params.height}" style="width:50px;margin-left:2px;margin-right:12px;"></label>
        <label>Profondeur :<input type="number" id="depth" min="1" max="20" step="0.1" value="${params.depth}" style="width:50px;margin-left:2px;"></label>
      `;
    } else if (currentShape === "sphere") {
      paramControls.innerHTML += `<label>Rayon :<input type="number" id="radius" min="1" max="20" step="0.1" value="${params.radius}" style="width:50px;margin-left:2px;"></label>`;
    } else if (currentShape === "cylinder" || currentShape === "cone") {
      paramControls.innerHTML += `
        <label>Rayon base :<input type="number" id="radius" min="0.5" max="20" step="0.1" value="${params.radius}" style="width:50px;margin-left:2px;margin-right:12px;"></label>
        <label>Hauteur :<input type="number" id="height" min="1" max="20" step="0.1" value="${params.height}" style="width:50px;margin-left:2px;"></label>
      `;
    } else if (currentShape === "prism") {
      paramControls.innerHTML += `
        <label>Base :<input type="number" id="base" min="1" max="20" step="0.1" value="${params.base || 5}" style="width:50px;margin-left:2px;margin-right:12px;"></label>
        <label>Hauteur :<input type="number" id="height" min="1" max="20" step="0.1" value="${params.height}" style="width:50px;margin-left:2px;"></label>
        <label>Profondeur :<input type="number" id="depth" min="1" max="20" step="0.1" value="${params.depth}" style="width:50px;margin-left:2px;"></label>
      `;
    } else if (currentShape === "galet") {
      paramControls.innerHTML += `
        <label>Longueur :<input type="number" id="length" min="1" max="20" step="0.1" value="${params.length}" style="width:50px;margin-left:2px;margin-right:12px;"></label>
        <label>Épaisseur :<input type="number" id="height" min="0.5" max="10" step="0.1" value="${params.height}" style="width:50px;margin-left:2px;margin-right:12px;"></label>
        <label>Aplatissement :<input type="number" id="flatten" min="0.5" max="2" step="0.01" value="${params.flatten}" style="width:50px;margin-left:2px;"></label>
      `;
    }
    Array.from(paramControls.querySelectorAll("input")).forEach(input => {
      input.addEventListener("input", (e) => {
        params[input.id] = parseFloat(e.target.value);
        createShape();
      });
    });
  }

  // --- Crée ou met à jour la forme (garantie face plane)
  function createShape() {
    if (currentShape !== "cube" && modeLibre) setModeLibre(false);
    if (mesh) { scene.remove(mesh); mesh.geometry.dispose(); }
    params.rugosite = parseFloat(rugositeSlider.value);

    switch (currentShape) {
      case "cube":
        geometry = new THREE.BoxGeometry(params.width, params.height, params.depth, 32, 32, 32);
        break;
      case "sphere":
        geometry = new THREE.SphereGeometry(params.radius, 48, 24);
        break;
      case "cylinder":
        geometry = new THREE.CylinderGeometry(params.radius, params.radius, params.height, 48, 8, false);
        break;
      case "cone":
        geometry = new THREE.ConeGeometry(params.radius, params.height, 32, 8, false);
        break;
      case "pyramid":
        geometry = new THREE.ConeGeometry(params.width / 2, params.height, 4, 1, false);
        break;
      case "prism":
        geometry = createPrismGeometry(params.base || 5, params.height, params.depth);
        break;
      case "galet":
        geometry = createGaletGeometry(params.length, params.height, params.flatten || 1);
        break;
      default:
        geometry = new THREE.BoxGeometry(5, 5, 5, 32, 32, 32);
    }

    // 1. Fixe la face du dessous (plane)
    flattenBottomFace(geometry);

    // 2. Rugosité uniquement si pas mode libre
    if (params.rugosite > 0.01 && !modeLibre) applyRugosite(geometry, params.rugosite);

    mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ color: 0x2194ce }));
    scene.add(mesh);

    if (currentShape === "cube" && modeLibre) {
      createVertexHelpers();
    } else {
      removeVertexHelpers();
    }
  }

  // --------- FORCAGE D'UNE FACE PLATE ---------
  function flattenBottomFace(geometry) {
    const pos = geometry.attributes.position;
    let minZ = +Infinity;
    for (let i = 0; i < pos.count; i++) {
      if (pos.getZ(i) < minZ) minZ = pos.getZ(i);
    }
    for (let i = 0; i < pos.count; i++) {
      if (Math.abs(pos.getZ(i) - minZ) < 0.01) pos.setZ(i, minZ);
    }
    pos.needsUpdate = true;
    geometry.computeVertexNormals();
  }

  // --- Galet paramétrique ---
  function createGaletGeometry(length = 6, height = 2, flatten = 1) {
    const points = [];
    const N = 30;
    for (let i = 0; i < N; i++) {
      const t = i / (N - 1);
      const r = (Math.sin(Math.PI * t) ** flatten) * (length / 2);
      const z = (t - 0.5) * height;
      points.push(new THREE.Vector2(r, z));
    }
    return new THREE.LatheGeometry(points, 64);
  }

  // --- Prisme triangulaire ---
  function createPrismGeometry(base = 5, height = 5, depth = 5) {
    const shape = new THREE.Shape();
    shape.moveTo(0, 0);
    shape.lineTo(base, 0);
    shape.lineTo(base / 2, Math.sqrt(3) / 2 * base);
    shape.lineTo(0, 0);
    const extrudeSettings = { steps: 1, depth: depth, bevelEnabled: false };
    const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    geo.rotateX(Math.PI / 2);
    geo.scale(1, height / base, 1);
    geo.center();
    return geo;
  }

  // --- Rugosité ---
  function applyRugosite(geometry, strength) {
    const pos = geometry.attributes.position;
    let minZ = +Infinity;
    for (let i = 0; i < pos.count; i++) if (pos.getZ(i) < minZ) minZ = pos.getZ(i);
    for (let i = 0; i < pos.count; i++) {
      if (Math.abs(pos.getZ(i) - minZ) < 0.01) continue; // Ne PAS bouger la face plane
      const v = new THREE.Vector3(pos.getX(i), pos.getY(i), pos.getZ(i));
      const noiseValue = noise.noise3D(v.x * 0.2, v.y * 0.2, v.z * 0.2);
      v.addScaledVector(v.clone().normalize(), noiseValue * strength);
      pos.setXYZ(i, v.x, v.y, v.z);
    }
    pos.needsUpdate = true;
    geometry.computeVertexNormals();
  }

  // --------- MODE LIBRE ---------
  function createVertexHelpers() {
    removeVertexHelpers();
    geometry = mesh.geometry;
    const pos = geometry.attributes.position;
    let uniqueVerts = [];
    let minZ = +Infinity;
    for (let i = 0; i < pos.count; i++) {
      const v = new THREE.Vector3(pos.getX(i), pos.getY(i), pos.getZ(i));
      if (!uniqueVerts.some(u => u.distanceTo(v) < 0.01)) uniqueVerts.push(v);
      if (pos.getZ(i) < minZ) minZ = pos.getZ(i);
    }
    uniqueVerts.forEach((v, idx) => {
      if (Math.abs(v.z - minZ) < 0.01) return; // N'affiche PAS de helper sur la face plane
      const helperGeom = new THREE.SphereGeometry(0.22, 16, 16);
      const helperMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      const helper = new THREE.Mesh(helperGeom, helperMat);
      helper.position.copy(v);
      helper.userData.vertexIndex = idx;
      scene.add(helper);
      vertexHelpers.push(helper);
    });
  }

  function removeVertexHelpers() {
    vertexHelpers.forEach(h => scene.remove(h));
    vertexHelpers = [];
  }

  // --- Drag & Drop sommet (helpers) ---
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  let selectedHelper = null;
  let dragOffset = new THREE.Vector3();

  function getMouseNDCCoords(event) {
    const rect = canvas.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  }

  canvas.addEventListener('pointerdown', (event) => {
    if (!modeLibre) return;
    getMouseNDCCoords(event);
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(vertexHelpers);
    if (intersects.length > 0) {
      selectedHelper = intersects[0].object;
      controls.enabled = false;
      dragOffset.copy(intersects[0].point).sub(selectedHelper.position);
    }
  });

  canvas.addEventListener('pointermove', (event) => {
    if (!modeLibre || !selectedHelper) return;
    getMouseNDCCoords(event);
    raycaster.setFromCamera(mouse, camera);
    const planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1).applyQuaternion(camera.quaternion), selectedHelper.position.dot(new THREE.Vector3(0, 0, 1).applyQuaternion(camera.quaternion)));
    const intersect = new THREE.Vector3();
    raycaster.ray.intersectPlane(planeZ, intersect);
    if (intersect) {
      selectedHelper.position.copy(intersect.sub(dragOffset));
      updateCubeGeometryFromHelpers();
    }
  });

  window.addEventListener('pointerup', () => {
    if (selectedHelper) {
      controls.enabled = true;
      selectedHelper = null;
    }
  });

  function updateCubeGeometryFromHelpers() {
    const pos = geometry.attributes.position;
    let uniqueVerts = [];
    let minZ = +Infinity;
    for (let i = 0; i < pos.count; i++) {
      const v = new THREE.Vector3(pos.getX(i), pos.getY(i), pos.getZ(i));
      if (!uniqueVerts.some(u => u.distanceTo(v) < 0.01)) uniqueVerts.push(v);
      if (pos.getZ(i) < minZ) minZ = pos.getZ(i);
    }
    for (let i = 0; i < pos.count; i++) {
      for (let j = 0; j < uniqueVerts.length; j++) {
        if (new THREE.Vector3(pos.getX(i), pos.getY(i), pos.getZ(i)).distanceTo(uniqueVerts[j]) < 0.01) {
          // Si c'est un sommet de la face plane (minZ), on le force à rester sur le plan
          if (Math.abs(uniqueVerts[j].z - minZ) < 0.01) {
            pos.setZ(i, minZ);
          } else {
            pos.setXYZ(i,
              vertexHelpers[j > helpersForPlane() ? j - helpersForPlane() : j].position.x,
              vertexHelpers[j > helpersForPlane() ? j - helpersForPlane() : j].position.y,
              vertexHelpers[j > helpersForPlane() ? j - helpersForPlane() : j].position.z
            );
          }
        }
      }
    }
    pos.needsUpdate = true;
    geometry.computeVertexNormals();
  }

  // Helper pour compter les sommets de la face plane (pour indexer vertexHelpers correctement)
  function helpersForPlane() {
    const pos = geometry.attributes.position;
    let uniqueVerts = [];
    let minZ = +Infinity;
    let planeCount = 0;
    for (let i = 0; i < pos.count; i++) {
      const v = new THREE.Vector3(pos.getX(i), pos.getY(i), pos.getZ(i));
      if (!uniqueVerts.some(u => u.distanceTo(v) < 0.01)) uniqueVerts.push(v);
      if (pos.getZ(i) < minZ) minZ = pos.getZ(i);
    }
    uniqueVerts.forEach((v) => {
      if (Math.abs(v.z - minZ) < 0.01) planeCount++;
    });
    return planeCount;
  }

  // --- UI mode libre
  modeLibreBtn.addEventListener('click', () => {
    if (currentShape === "cube") setModeLibre(!modeLibre);
  });
  function setModeLibre(val) {
    modeLibre = val;
    modeLibreBtn.style.background = modeLibre ? "#ddd" : "";
    modeLibreLabel.style.display = modeLibre ? "inline" : "none";
    createShape();
  }

  // --- Listeners UI
  shapeSelect.addEventListener("change", (e) => {
    currentShape = e.target.value;
    updateParamControls();
    createShape();
  });
  rugositeSlider.addEventListener("input", () => {
    rugositeValue.innerText = rugositeSlider.value;
    if (!modeLibre) createShape();
  });

  window.addEventListener('resize', () => {
    camera.aspect = canvas.clientWidth / 400;
    camera.updateProjectionMatrix();
    renderer.setSize(canvas.clientWidth, 400, false);
  });

  document.getElementById('export-btn').addEventListener('click', () => {
    const exporter = new THREE.STLExporter();
    const stlString = exporter.parse(mesh);
    const blob = new Blob([stlString], { type: 'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'custom-hold.stl';
    a.click();
  });

  // Initialisation
  updateParamControls();
  createShape();

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();
});
